---
alwaysApply: true
---

We need to ensure thorughout our whole app we have proper error handling and helpful error/success messaages to the user.

# Database
    - Always refer to database.types.ts to understand up-to-date database schema 

    **Migration Workflow (ALWAYS follow):**
    1. Create migration: `supabase migration new <name>`
    2. Apply to DB: `supabase db push`
    3. **Regenerate types**: `npx supabase gen types typescript --project-id vezidnvayhhlhcwnqbzp > lib/supabase/database.types.ts`

    **Never manually edit `database.types.ts`** - always regenerate from live schema to avoid drift. 

# React Performance Rules

## 1. Memoize Callback Props
    **Rule:** Always wrap callback functions in `useCallback` when passing them as props to child components.

    **Why:** Functions are recreated on every render. If a child component's `useEffect` depends on that callback, it will re-run unnecessarily, potentially destroying/recreating expensive resources (like BPMN viewers, charts, etc.).

    **Example:**
    ```tsx
    // ❌ BAD - Function recreated every render
    const handleClick = (id: string) => {
    doSomething(id);
    };

    // ✅ GOOD - Stable function reference
    const handleClick = useCallback((id: string) => {
    doSomething(id);
    }, [dependencies]);
    ```

    **When to use:**
    - Callbacks passed to child components
    - Callbacks in useEffect dependencies
    - Event handlers passed to memoized components


## Server Components & Client Components

### The Architecture Pattern
**Server Components** = Initial data fetching (fast, SEO-friendly, no loading spinners)
**Client Components** = Interactivity (clicks, forms, real-time updates)

### ✅ DO
- **Default to Server Components** - Only add `"use client"` when you need hooks, event handlers, or browser APIs
- **Fetch initial data on server** - Use `async` functions in Server Components, pass data as props to Client Components
- **Prefetch in Server Components** - Treat them as the "data preparation layer" before client interactivity
- **Be surgical with "use client"** - Apply it to the smallest component that needs interactivity, not the entire page

### ❌ DON'T
- **Don't use "use client" on page-level components** - Pages should be Server Components that fetch data and compose Client Components
- **Don't fetch in useEffect** - If data can be fetched on server, do it there (faster, better UX)
- **Don't expose database queries in client** - All database operations must go through API routes (security + validation)
- **Don't make entire component trees client-side** - Each `"use client"` makes that component AND all children client-side

---

## React Query: State Management & Caching

### Philosophy for PolicyPal
**Goal:** Optimistic updates + minimal loading + cost-efficient AI calls

### ✅ DO

**Initial Data Pattern (Server → Client handoff):**
- Server Component fetches data → passes as `initialData` to React Query → Client Component has instant data, can mutate

**Optimistic Updates (Default pattern):**
- Use `onMutate` to update cache immediately (instant UI feedback)
- Use `onError` to rollback if mutation fails
- Use `onSettled` to refetch/sync after mutation completes
- **Result:** User sees change instantly, background sync ensures accuracy

**Mutation Callbacks:**
- Use `mutate` with callbacks (onSuccess, onError, onSettled) - simpler, clearer
- Only use `mutateAsync` if you need `try/catch` or `await` for dependent logic

**Query Keys (Consistent structure):**
- Format: `[resource, id?, filter?]` (e.g., `["documents"]`, `["documents", docId]`, `["conversations", userId]`)
- Enables surgical cache invalidation (e.g., invalidate all document queries, or just one document)

**Error Handling:**
- React Query retries 3 times by default with exponential backoff
- Set `retry: 1` for mutations (don't retry failed uploads 3 times)
- Show user-friendly error messages using `error` object from mutation/query

**Cache Invalidation (After mutations):**
- `queryClient.invalidateQueries(["documents"])` - Refetch all document queries
- `queryClient.setQueryData(["documents", id], newData)` - Optimistic update specific item
- Use both together: optimistic update + invalidate for eventual consistency

### ❌ DON'T

- **Don't use React Query for fetching in Server Components** - Server Components should use direct DB/API calls, not `useQuery`
- **Don't skip optimistic updates** - Users expect instant feedback (especially for upload/delete)
- **Don't use inconsistent query keys** - Breaks cache invalidation (e.g., `["docs"]` vs `["documents"]` won't sync)
- **Don't forget initialData** - Causes unnecessary loading spinners even though server already fetched data
- **Don't refetch on every window focus for expensive operations** - AI calls, embeddings, large document lists should have `refetchOnWindowFocus: false`
- **Don't use mutateAsync by default** - Callbacks are clearer and prevent promise-handling confusion

---

## React Query + Server Components: The Full Pattern

**The handoff flow:**
1. **Server Component (Page):** Fetch data directly from Supabase/API → render instantly
2. **Client Component:** Receive data as `initialData` prop → wrap in React Query hook
3. **User interacts:** Mutation triggered → optimistic update → API call → invalidate cache → refetch
4. **Result:** Fast initial load + instant interactions + always in sync

**Example mental model:**
- Landing page loads `/dashboard` (Server Component fetches conversations + documents)
- Client Components receive that data (no loading spinner, instant display)
- User uploads document (optimistic update shows it immediately in list)
- Background: FastAPI processes PDF, chunks, embeds (expensive, takes 10s)
- On success: Cache invalidates, refetches documents with new doc's metadata
- On error: Rollback optimistic update, show error message

**Security boundary:**
- Server Components: Can access DB, secrets, run expensive operations
- API routes: Authentication gate between Client Components and sensitive operations
- Client Components: Only UI state, user interactions, visual updates (never direct DB access)