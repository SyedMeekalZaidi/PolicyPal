"use client";

// Inserts a new conversation row. ID is generated by the caller (crypto.randomUUID())
// so the component can navigate to /dashboard/{id} in onSuccess without waiting.
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createClient } from "@/lib/supabase/client";
import { CONVERSATIONS_QUERY_KEY } from "@/hooks/queries/use-conversations";
import type { ConversationRow } from "@/lib/types/conversations";

type CreateConversationArgs = {
  id: string;
  title: string;
};

export function useCreateConversation() {
  const queryClient = useQueryClient();
  const supabase = createClient();

  return useMutation({
    mutationFn: async ({
      id,
      title,
    }: CreateConversationArgs): Promise<ConversationRow> => {
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) throw new Error("Not authenticated");

      const { data, error } = await supabase
        .from("conversations")
        .insert({ id, title, user_id: user.id })
        .select("*")
        .single();

      if (error) throw new Error(error.message);
      return data as ConversationRow;
    },

    onMutate: async ({ id, title }) => {
      await queryClient.cancelQueries({ queryKey: CONVERSATIONS_QUERY_KEY });

      const previousConversations =
        queryClient.getQueryData<ConversationRow[]>(CONVERSATIONS_QUERY_KEY);

      const now = new Date().toISOString();
      const optimisticConversation: ConversationRow = {
        id,
        title,
        user_id: "optimistic",
        last_message_at: now,
        created_at: now,
      };

      // Prepend â€” newest appears at top of list
      queryClient.setQueryData<ConversationRow[]>(
        CONVERSATIONS_QUERY_KEY,
        (old) => [optimisticConversation, ...(old ?? [])]
      );

      return { previousConversations };
    },

    onError: (_error, _variables, context) => {
      if (context?.previousConversations !== undefined) {
        queryClient.setQueryData(
          CONVERSATIONS_QUERY_KEY,
          context.previousConversations
        );
      }
    },

    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: CONVERSATIONS_QUERY_KEY });
    },
  });
}
